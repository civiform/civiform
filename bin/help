#! /usr/bin/env bash

# DOC: Print descriptions of each bin script.
# DOC: Use --help for optional usage flags

source bin/lib.sh

function print_help {
  echo "Usage: 
  ${0} [options] 

OPTIONS
  -h, --help          show list of command-line options
  -n, --no-color      disable colorized output 
  -s, --single-line   print file name and help text on the same line (useful for grep)"
}

# Get arguments
opts="$(getopt \
  --options "hns" \
  --longoptions "help,no-color,single-line" \
  -- "${@}"
)" || exit

# Required for getopt to safely and correctly parse
eval set -- "${opts}"

NO_COLOR_OUTPUT="false"
SINGLE_LINE_OUTPUT="false"

while [[ "${#}" -gt 0 ]]; do
  case "${1}" in 
    -h | --help)
      print_help
      exit 0;;
    -n | --no-color)
      NO_COLOR_OUTPUT="true"
      shift 1;;
    -s | --single-line)
      SINGLE_LINE_OUTPUT="true"
      shift 1;;
    *)
      break
      ;;
  esac
done


# Set up variables
FILENAME_SEPARATOR="\n"

if [[ "${SINGLE_LINE_OUTPUT}" == "true" ]]; then
  FILENAME_SEPARATOR=" "
fi

# Define variables with ANSI color codes to enable color output
COLOR_FILENAME="\033[0;35m" # 35 is magenta unless the pc overrides the color
COLOR_ERROR="\033[0;31m"    # 31 is red unless the pc overrides the color
COLOR_RESET="\033[0m"       # This is the reset code to set output back to default color

# Set the ANSI color code variables to nothing in order to print without color
if [[ "${NO_COLOR_OUTPUT}" == "true" ]]; then
  COLOR_FILENAME=""
  COLOR_ERROR=""
  COLOR_RESET=""
fi

# Make variables readonly
readonly NO_COLOR_OUTPUT
readonly SINGLE_LINE_OUTPUT
readonly COLOR_FILENAME
readonly COLOR_ERROR
readonly COLOR_RESET

# Begin work
FILES_MISSING_DOCSTRING=()

# Get a sort list of potential files with help text
HELP_FILES="$(find bin \
  -type f \
  -not -iname '*.sh' \
  -not -iname "*.py" \
  -not -iname "*.pyc" \
  | sort)"

while read -r HELP_FILE; do
  # Pull the help text from the file and remove the doc string token for easier reading
  HELP_TEXT="$(grep --regexp "^# DOC\:" "${HELP_FILE}" \
    | sed -e "s/^\# DOC\: //")"

  # Remove extra lines break when in single line mode
  if [[ "${SINGLE_LINE_OUTPUT}" == "true" ]]; then
    HELP_TEXT="$(echo "${HELP_TEXT}" | awk 1 ORS=" ")"
  fi

  # Print formatted string of file name and help text when there is help text found or
  # store the file in the missing list
  if [[ -n "${HELP_TEXT}" ]]; then
    printf "%b%s\n\n" "${COLOR_FILENAME}${HELP_FILE}${COLOR_RESET}${FILENAME_SEPARATOR}" "${HELP_TEXT}"
  else
    FILES_MISSING_DOCSTRING+=("$HELP_FILE")
  fi
done <<< "${HELP_FILES}"

# Print a full list of files that are missing help text
if [[ "${#FILES_MISSING_DOCSTRING[@]}" -gt 0 ]]; then
  printf "%b\n" "${COLOR_ERROR}----------------------------------------------------------${COLOR_RESET}"
  printf "%b\n" "${COLOR_ERROR}The following file(s) are missing a docstring. Please fix.${COLOR_RESET}"
  printf "%b\n" "${COLOR_ERROR}----------------------------------------------------------${COLOR_RESET}"
  printf "* %s\n" "${FILES_MISSING_DOCSTRING[@]}"
  exit 1
fi

exit 0
