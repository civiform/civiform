#! /usr/bin/env bash

# DOC: Load a postgres dump into the dev database (pg_restore), replacing whatever state is currently in it. Takes a file name argument, file must be in project base directory.

source bin/lib.sh

if [[ ! -f "${1}" ]]; then
  echo "Usage: bin/dev-restore-db DUMP_FILE_NAME"
  exit 1
fi

# set TRUNCATE_SQL to heredoc contents
TRUNCATE_SQL=$(cat <<EOF
TRUNCATE TABLE files;
TRUNCATE TABLE applications CASCADE;
TRUNCATE TABLE applicants CASCADE;
TRUNCATE TABLE accounts CASCADE;
TRUNCATE TABLE programs CASCADE;
TRUNCATE TABLE questions;
TRUNCATE TABLE versions;
TRUNCATE TABLE versions_programs;
TRUNCATE TABLE versions_questions;
EOF
)

# remove newlines
TRUNCATE_SQL="${TRUNCATE_SQL//$'\n'/}"

# location of dump file in docker container
readonly DUMP_FILE="project/${1}"

readonly COMPOSE_CMD="docker compose \
  -f docker-compose.yml \
  -f docker-compose.dev.yml"

docker::set_network_name_dev

${COMPOSE_CMD} up db \
  --no-deps \
  --wait \
  -d

${COMPOSE_CMD} cp ${1} db:/${DUMP_FILE}

# command for invoking psql with the dev database
${COMPOSE_CMD} \
  exec -it -e "PGPASSWORD=example" db \
  /usr/bin/psql -h db -U postgres \
  -c "${TRUNCATE_SQL}" postgres

# command for invoking pg_restore with the dev database
${COMPOSE_CMD} \
  exec -it -e "PGPASSWORD=example" db \
  /usr/bin/pg_restore -h db -U postgres \
   -f "${DUMP_FILE}"
