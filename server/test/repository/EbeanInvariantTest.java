package repository;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;

import io.ebean.DB;
import io.ebean.Database;
import io.ebean.Transaction;
import io.ebean.TxScope;
import io.ebean.annotation.TxIsolation;
import java.util.Locale;
import junitparams.JUnitParamsRunner;
import junitparams.Parameters;
import models.AccountModel;
import models.QuestionModel;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import services.LocalizedStrings;
import services.question.types.QuestionDefinition;
import services.question.types.QuestionDefinitionConfig;
import services.question.types.TextQuestionDefinition;

/**
 * Ebean documentation is unfortunately sparse without a lot of practical examples.
 *
 * <p>The following serves as documentation and verification of believed invariants in how Ebean
 * actually operates, and possibly serves as a guard for changes in future Ebean releases.
 */
@RunWith(JUnitParamsRunner.class)
public class EbeanInvariantTest extends ResetPostgres {

  private static final QuestionDefinition QUESTION_DEFINITION =
      new TextQuestionDefinition(
          QuestionDefinitionConfig.builder()
              .setName("question")
              .setDescription("applicant's name")
              .setQuestionText(LocalizedStrings.of(Locale.US, "What is your name?"))
              .setQuestionHelpText(LocalizedStrings.empty())
              .build());

  private Database database;

  @Before
  public void setup() {
    database = DB.getDefault();
  }

  /*  Auto generated ID tests.
   *
   * When a new Model is added to the database, auto generated IDs are created
   * and set on the object automatically.
   *
   * The exception to this is for Batch queries where they are not, because the
   * insert has most likely not been sent to the DB which generates the IDs.
   */

  @Test
  public void autoGeneratedIds_areAutoSetOnObjects_save() {
    QuestionModel questionModel = new QuestionModel(QUESTION_DEFINITION);
    assertNull(questionModel.id);

    questionModel.save();

    assertNotNull(questionModel.id);
    assertThat(questionModel.id).isGreaterThanOrEqualTo(0);
  }

  @Test
  public void autoGeneratedIds_areAutoSetOnObjects_insert() {
    QuestionModel questionModel = new QuestionModel(QUESTION_DEFINITION);
    assertNull(questionModel.id);

    questionModel.insert();

    assertNotNull(questionModel.id);
    assertThat(questionModel.id).isGreaterThanOrEqualTo(0);
  }

  /* Note that we're not calling Transaction.commit() through the Transaction
  cases, partially because it's not needed for these tests, as well it
  illustrates what's true without a commit(). */

  @Test
  public void autoGeneratedIds_areAutoSetOnObjects_withTransaction() {
    try (Transaction ignore =
        database.beginTransaction(TxScope.required().setIsolation(TxIsolation.SERIALIZABLE))) {
      QuestionModel questionModel = new QuestionModel(QUESTION_DEFINITION);
      assertNull(questionModel.id);

      questionModel.save();

      assertNotNull(questionModel.id);
      assertThat(questionModel.id).isGreaterThanOrEqualTo(0);
    }
  }

  @Test
  public void autoGeneratedIds_areNotAutoSetOnObjects_withBatchTransaction_mustRefresh() {
    try (Transaction transaction =
        database.beginTransaction(TxScope.required().setIsolation(TxIsolation.SERIALIZABLE))) {
      transaction.setBatchMode(true);
      QuestionModel questionModel = new QuestionModel(QUESTION_DEFINITION);
      assertNull(questionModel.id);

      questionModel.save();

      // ID is NOT set because the save is queued in the server.
      assertNull(questionModel.id);

      // Must refresh to get the ID.
      // Does a select statement for the ID which Ebean seems to know already,
      // this should update M2M properties too.
      questionModel.refresh();

      assertNotNull(questionModel.id);
      assertThat(questionModel.id).isGreaterThanOrEqualTo(0);
    }
  }

  @Test
  public void autoGeneratedIds_areNotAutoSetOnObjects_withBatchTransaction_canFlush() {
    try (Transaction transaction =
        database.beginTransaction(TxScope.required().setIsolation(TxIsolation.SERIALIZABLE))) {
      transaction.setBatchMode(true);
      QuestionModel questionModel = new QuestionModel(QUESTION_DEFINITION);
      assertNull(questionModel.id);

      questionModel.save();

      // ID is NOT set because the save is queued in the server.
      assertNull(questionModel.id);

      // Flushing sends the batch to the DB prematurely.
      // Needing to flush in a batch may indicate a data flow smell, but is possibly still better
      // than not batching.
      // This does no additional select, Ebean already knows the ID, note that other information
      // like M2M relations are likely not updated which refresh() does.
      // transaction.commit() is identical to flush it seems.
      questionModel.flush();

      // ID is now set.
      assertNotNull(questionModel.id);
      assertThat(questionModel.id).isGreaterThanOrEqualTo(0);
    }
  }

  /* Transactions */

  /**
   * When using TxScope.required(), as we should, inner transactions become part of outer ones with
   * the top level one ultimately having control over commiting or not.
   *
   * <p>Savepoints do not change this behavior. See later for Savepoint usage.
   */
  @Test
  @Parameters({"false", "true"})
  public void transaction_innerIsNotIsolated(Boolean useSavepoint) {
    assertThat(DB.find(AccountModel.class).findCount()).isEqualTo(0);
    try (Transaction outerTransaction =
        DB.beginTransaction(TxScope.required().setIsolation(TxIsolation.SERIALIZABLE))) {

      if (useSavepoint) {
        outerTransaction.setNestedUseSavepoint();
      }

      try (Transaction innerTransaction =
          DB.beginTransaction(TxScope.required().setIsolation(TxIsolation.SERIALIZABLE))) {
        new AccountModel().insert();
        // Within the inner transaction we see the new account.
        assertThat(DB.find(AccountModel.class).findCount()).isEqualTo(1);
        // This commit is required to save the changes, but doesn't actually
        // commit to the database because it isn't on the outermost transaction.
        innerTransaction.commit();
      }

      // In the outer transaction we see the new account.
      assertThat(DB.find(AccountModel.class).findCount()).isEqualTo(1);

      // Note: No commit to simulate that the outer transaction controls everything
      // try-with-resources handles the rollback/end.
    }

    // Outside of both transactions, everything is rolled back.
    assertThat(DB.find(AccountModel.class).findCount()).isEqualTo(0);
  }

  /**
   * Not commiting in an inner transaction causes weirdness.
   *
   * <p>This is a good reason to use TransactionManager.execute()
   */
  @Test
  public void transaction_mustCommitInInnerTransaction() {
    final long outerAccountId;
    assertThat(DB.find(AccountModel.class).findCount()).isEqualTo(0);
    try (Transaction outerTransaction =
        DB.beginTransaction(TxScope.required().setIsolation(TxIsolation.SERIALIZABLE))) {
      new AccountModel().insert();

      // Enabling nested savepoints produces the expected behavior where
      // nothing is saved from the transactions:
      // outerTransaction.setNestedUseSavepoint();
      try (Transaction innerTransaction =
          DB.beginTransaction(TxScope.required().setIsolation(TxIsolation.SERIALIZABLE))) {
        new AccountModel().insert();
        // Assert that from within this inner transaction, we see the new account
        assertThat(DB.find(AccountModel.class).findCount()).isEqualTo(2);
        // Not commiting seems to create the problem.
        // A rollback is done here as expected.
      }

      // WARNING: We don't see the inner data as expected, but we also don't see the first one
      // made before innerTransaction! The inner rollback affected everything since the start of the
      // outer transaction. If we used setNestedUseSavepoint() the initial data would still exist.
      assertThat(DB.find(AccountModel.class).findCount()).isEqualTo(0);

      // From the logs we see a new transaction is used starting here.
      // The issue is also triggered by this .insert(). The expected outcome
      // where the last assert outside the transactions sees nothing happens
      // without this insert.
      var account = new AccountModel();
      account.insert();
      outerAccountId = account.id;
      // We see the new one in the outer.
      assertThat(DB.find(AccountModel.class).findCount()).isEqualTo(1);

      // WARNING: TXN logging shows a commit happens, despite it not being here.
    }

    // For some reason we see the outer one.
    assertThat(DB.find(AccountModel.class).findIds()).containsExactly(outerAccountId);
  }

  /**
   * Rolling back some but not all of a transaction doesn't usually make sense for our code but
   * nested savepoints is how to do that.
   */
  @Test
  public void transaction_nestedSavePointsAllowForInnerRollbacks() {
    final long outerAccountId;
    assertThat(DB.find(AccountModel.class).findCount()).isEqualTo(0);
    try (Transaction outerTransaction =
        DB.beginTransaction(TxScope.required().setIsolation(TxIsolation.SERIALIZABLE))) {

      // Add in the outer transaction.
      var account = new AccountModel();
      account.insert();
      outerAccountId = account.id;
      assertThat(DB.find(AccountModel.class).findIds()).containsExactly(outerAccountId);

      outerTransaction.setNestedUseSavepoint();
      try (Transaction innerTransaction =
          DB.beginTransaction(TxScope.required().setIsolation(TxIsolation.SERIALIZABLE))) {
        new AccountModel().insert();
        // Assert that from within this inner transaction, we see the new account
        assertThat(DB.find(AccountModel.class).findCount()).isEqualTo(2);
        // Decide we don't really want this
        innerTransaction.rollback();
      }

      // We only see the outer data and not the inner as expected.
      assertThat(DB.find(AccountModel.class).findIds()).containsExactly(outerAccountId);
      // Keep this one.
      outerTransaction.commit();
    }

    // We still only see the outer data.
    assertThat(DB.find(AccountModel.class).findIds()).containsExactly(outerAccountId);
  }

  /**
   * While we don't use batch mode often, be careful about its semantics.
   *
   * <p>In a previous test we see that IDs aren't auto loaded when it is on, and here we see that
   * enabling batches is sticky for the entire transaction beyond when it is set.
   */
  @Test
  public void transaction_innerBatchModeEnablesForEntireTransaction() {
    try (Transaction outerTransaction =
        DB.beginTransaction(TxScope.required().setIsolation(TxIsolation.SERIALIZABLE))) {
      // Not set as expected.
      assertThat(outerTransaction.isBatchMode()).isFalse();

      try (Transaction innerTransaction =
          DB.beginTransaction(TxScope.required().setIsolation(TxIsolation.SERIALIZABLE))) {
        innerTransaction.setBatchMode(true);
        var account = new AccountModel();
        account.insert();
        // In batch mode we don't get IDs without a refresh.
        assertNull(account.id);

        innerTransaction.commit();
      }

      // WARNING: Batch mode is on out here too, somewhat unexpectedly.
      assertThat(outerTransaction.isBatchMode()).isTrue();

      var account = new AccountModel();
      account.insert();
      // In batch mode we don't get IDs without a refresh.
      assertNull(account.id);

      // Turn off batch mode, which flushes the batch.
      outerTransaction.setBatchMode(false);

      account = new AccountModel();
      account.insert();
      // Outside of batch mode we now get IDs.
      assertNotNull(account.id);

      // All 3 are present in the DB.
      assertThat(DB.find(AccountModel.class).findCount()).isEqualTo(3);
    }
  }
}
