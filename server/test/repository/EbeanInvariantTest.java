package repository;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;

import io.ebean.DB;
import io.ebean.Database;
import io.ebean.Transaction;
import io.ebean.TxScope;
import io.ebean.annotation.TxIsolation;
import java.util.Locale;
import junitparams.JUnitParamsRunner;
import junitparams.Parameters;
import models.AccountModel;
import models.QuestionModel;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import services.LocalizedStrings;
import services.question.types.QuestionDefinition;
import services.question.types.QuestionDefinitionConfig;
import services.question.types.TextQuestionDefinition;

/**
 * Ebean documentation is unfortunately sparse without a lot of practical examples.
 *
 * <p>The following serves as documentation and verification of believed invariants in how Ebean
 * actually operates, and possibly serves as a guard for changes in future Ebean releases.
 */
@RunWith(JUnitParamsRunner.class)
public class EbeanInvariantTest extends ResetPostgres {

  private static final QuestionDefinition QUESTION_DEFINITION =
      new TextQuestionDefinition(
          QuestionDefinitionConfig.builder()
              .setName("question")
              .setDescription("applicant's name")
              .setQuestionText(LocalizedStrings.of(Locale.US, "What is your name?"))
              .setQuestionHelpText(LocalizedStrings.empty())
              .build());

  private Database database;

  @Before
  public void setup() {
    database = DB.getDefault();
  }

  /*  Auto generated ID tests.
   *
   * When a new Model is added to the database, auto generated IDs are created
   * and set on the object automatically.
   *
   * The exception to this is for Batch queries where they are not, because the
   * insert has most likely not been sent to the DB which generates the IDs.
   */

  @Test
  public void autoGeneratedIds_areAutoSetOnObjects_save() {
    QuestionModel questionModel = new QuestionModel(QUESTION_DEFINITION);
    assertNull(questionModel.id);

    questionModel.save();

    assertNotNull(questionModel.id);
    assertThat(questionModel.id).isGreaterThanOrEqualTo(0);
  }

  @Test
  public void autoGeneratedIds_areAutoSetOnObjects_insert() {
    QuestionModel questionModel = new QuestionModel(QUESTION_DEFINITION);
    assertNull(questionModel.id);

    questionModel.insert();

    assertNotNull(questionModel.id);
    assertThat(questionModel.id).isGreaterThanOrEqualTo(0);
  }

  /* Note that we're not calling Transaction.commit() through the Transaction
  cases, partially because it's not needed for these tests, as well it
  illustrates what's true without a commit(). */

  @Test
  public void autoGeneratedIds_areAutoSetOnObjects_withTransaction() {
    try (Transaction ignore =
        database.beginTransaction(TxScope.required().setIsolation(TxIsolation.SERIALIZABLE))) {
      QuestionModel questionModel = new QuestionModel(QUESTION_DEFINITION);
      assertNull(questionModel.id);

      questionModel.save();

      assertNotNull(questionModel.id);
      assertThat(questionModel.id).isGreaterThanOrEqualTo(0);
    }
  }

  @Test
  public void autoGeneratedIds_areNotAutoSetOnObjects_withBatchTransaction_mustRefresh() {
    try (Transaction transaction =
        database.beginTransaction(TxScope.required().setIsolation(TxIsolation.SERIALIZABLE))) {
      transaction.setBatchMode(true);
      QuestionModel questionModel = new QuestionModel(QUESTION_DEFINITION);
      assertNull(questionModel.id);

      questionModel.save();

      // ID is NOT set because the save is queued in the server.
      assertNull(questionModel.id);

      // Must refresh to get the ID.
      // Does a select statement for the ID which Ebean seems to know already,
      // this should update M2M properties too.
      questionModel.refresh();

      assertNotNull(questionModel.id);
      assertThat(questionModel.id).isGreaterThanOrEqualTo(0);
    }
  }

  @Test
  public void autoGeneratedIds_areNotAutoSetOnObjects_withBatchTransaction_canFlush() {
    try (Transaction transaction =
        database.beginTransaction(TxScope.required().setIsolation(TxIsolation.SERIALIZABLE))) {
      transaction.setBatchMode(true);
      QuestionModel questionModel = new QuestionModel(QUESTION_DEFINITION);
      assertNull(questionModel.id);

      questionModel.save();

      // ID is NOT set because the save is queued in the server.
      assertNull(questionModel.id);

      // Flushing sends the batch to the DB prematurely.
      // Needing to flush in a batch may indicate a data flow smell, but is possibly still better
      // than not batching.
      // This does no additional select, Ebean already knows the ID, note that other information
      // like M2M relations are likely not updated which refresh() does.
      // transaction.commit() is identical to flush it seems.
      questionModel.flush();

      // ID is now set.
      assertNotNull(questionModel.id);
      assertThat(questionModel.id).isGreaterThanOrEqualTo(0);
    }
  }

  /* Transactions */

  /**
   * When using TxScope.required(), as we should, inner transactions become part of outer ones with
   * the top level one ultimately having control over commiting or not.
   *
   * <p>Savepoints do not change this behavior. See later for Savepoint usage.
   */
  @Test
  @Parameters({"false", "true"})
  public void transaction_innerIsNotIsolated(Boolean useSavepoint) {
    assertThat(DB.find(AccountModel.class).findCount()).isEqualTo(0);
    try (Transaction outerTransaction =
        DB.beginTransaction(TxScope.required().setIsolation(TxIsolation.SERIALIZABLE))) {

      if (useSavepoint) {
        outerTransaction.setNestedUseSavepoint();
      }

      try (Transaction innerTransaction =
          DB.beginTransaction(TxScope.required().setIsolation(TxIsolation.SERIALIZABLE))) {
        new AccountModel().insert();
        // Within the inner transaction we see the new account.
        assertThat(DB.find(AccountModel.class).findCount()).isEqualTo(1);
        // This commit is required to save the changes, but doesn't actually
        // commit to the database because it isn't on the outermost transaction.
        innerTransaction.commit();
      }

      // In the outer transaction we see the new account.
      assertThat(DB.find(AccountModel.class).findCount()).isEqualTo(1);

      // Note: No commit to simulate that the outer transaction controls everything
      // try-with-resources handles the rollback/end.
    }

    // Outside of both transactions, everything is rolled back.
    assertThat(DB.find(AccountModel.class).findCount()).isEqualTo(0);
  }

  /**
   * Not commiting in an inner transaction causes weirdness.
   *
   * <p>This is a good reason to use TransactionManager.execute()
   */
  @Test
  public void transaction_mustCommitInInnerTransaction() {
    final long outerAccountId;
    assertThat(DB.find(AccountModel.class).findCount()).isEqualTo(0);
    try (Transaction outerTransaction =
        DB.beginTransaction(TxScope.required().setIsolation(TxIsolation.SERIALIZABLE))) {
      new AccountModel().insert();

      // Enabling nested savepoints produces the expected behavior where
      // nothing is saved from the transactions:
      // outerTransaction.setNestedUseSavepoint();
      try (Transaction innerTransaction =
          DB.beginTransaction(TxScope.required().setIsolation(TxIsolation.SERIALIZABLE))) {
        new AccountModel().insert();
        // Assert that from within this inner transaction, we see the new account
        assertThat(DB.find(AccountModel.class).findCount()).isEqualTo(2);
        // Not commiting seems to create the problem.
        // A rollback is done here as expected.
      }

      // WARNING: We don't see the inner data as expected, but we also don't see the first one
      // made before innerTransaction! The inner rollback affected everything since the start of the
      // outer transaction. If we used setNestedUseSavepoint() the initial data would still exist.
      assertThat(DB.find(AccountModel.class).findCount()).isEqualTo(0);

      // From the logs we see a new transaction is used starting here.
      // The issue is also triggered by this .insert(). The expected outcome
      // where the last assert outside the transactions sees nothing happens
      // without this insert.
      var account = new AccountModel();
      account.insert();
      outerAccountId = account.id;
      // We see the new one in the outer.
      assertThat(DB.find(AccountModel.class).findCount()).isEqualTo(1);

      // WARNING: TXN logging shows a commit happens, despite it not being here.
    }

    // For some reason we see the outer one.
    assertThat(DB.find(AccountModel.class).findIds()).containsExactly(outerAccountId);
  }

  /**
   * Rolling back some but not all of a transaction doesn't usually make sense for our code but
   * nested savepoints is how to do that.
   */
  @Test
  public void transaction_nestedSavePointsAllowForInnerRollbacks() {
    final long outerAccountId;
    assertThat(DB.find(AccountModel.class).findCount()).isEqualTo(0);
    try (Transaction outerTransaction =
        DB.beginTransaction(TxScope.required().setIsolation(TxIsolation.SERIALIZABLE))) {

      // Add in the outer transaction.
      var account = new AccountModel();
      account.insert();
      outerAccountId = account.id;
      assertThat(DB.find(AccountModel.class).findIds()).containsExactly(outerAccountId);

      outerTransaction.setNestedUseSavepoint();
      try (Transaction innerTransaction =
          DB.beginTransaction(TxScope.required().setIsolation(TxIsolation.SERIALIZABLE))) {
        new AccountModel().insert();
        // Assert that from within this inner transaction, we see the new account
        assertThat(DB.find(AccountModel.class).findCount()).isEqualTo(2);
        // Decide we don't really want this
        innerTransaction.rollback();
      }

      // We only see the outer data and not the inner as expected.
      assertThat(DB.find(AccountModel.class).findIds()).containsExactly(outerAccountId);
      // Keep this one.
      outerTransaction.commit();
    }

    // We still only see the outer data.
    assertThat(DB.find(AccountModel.class).findIds()).containsExactly(outerAccountId);
  }

  /** Batch mode is scoped to the transaction it is set in. */
  @Test
  public void transaction_innerBatchModeEnablesForInnerTransactionOnly() {
    try (Transaction outerTransaction =
        DB.beginTransaction(TxScope.required().setIsolation(TxIsolation.SERIALIZABLE))) {
      // Not set as expected.
      assertThat(outerTransaction.isBatchMode()).isFalse();

      try (Transaction innerTransaction =
          DB.beginTransaction(TxScope.required().setIsolation(TxIsolation.SERIALIZABLE))) {
        innerTransaction.setBatchMode(true);
        var account = new AccountModel();
        account.insert();
        // In batch mode we don't get IDs without a refresh.
        assertNull(account.id);

        innerTransaction.commit();
      }

      // Batch mode is off still in the outer transaction as expected.
      assertThat(outerTransaction.isBatchMode()).isFalse();

      // The batch IDs are available in the outer transaction.
      assertThat(DB.find(AccountModel.class).findCount()).isEqualTo(1);

      var account = new AccountModel();
      account.insert();
      // Outside of batch mode we now get IDs.
      assertNotNull(account.id);

      // Both are present in the DB.
      assertThat(DB.find(AccountModel.class).findCount()).isEqualTo(2);
    }
  }

  /*
   * Ebean has an L1 cache that affects Transactions.  Within a Transaction, Ebean's Persistence
   * Context returns the same Java object for the same logical DB data.
   *
   * The idea is to provide consistency in accessing database objects; however it runs counter to
   * the typical programming model in CiviForm where the lookups are assumed to be different
   * views of the same data.
   *
   * requriesNew() and savepoints change this behavior.
   *
   * <p>https://ebean.io/architecture/persistence-context
   */

  /** Basic example of the Transactional Persistence Context. */
  @Test
  public void transaction_sameObjectsInTransaction() {
    final String ORIGINAL_EMAIL = "original@email.com";
    final String UPDATED_EMAIL = "updated@email.com";
    var account = new AccountModel();
    account.setEmailAddress(ORIGINAL_EMAIL);
    account.insert();

    var accountId = account.id;

    // Look up the account.
    var outerAccount1 = database.find(AccountModel.class).setId(accountId).findOne();
    assertThat(outerAccount1.getEmailAddress()).isEqualTo(ORIGINAL_EMAIL);

    try (Transaction transaction =
        DB.beginTransaction(TxScope.required().setIsolation(TxIsolation.SERIALIZABLE))) {
      // Look up the account in a transaction.
      var innerAccount1 = database.find(AccountModel.class).setId(accountId).findOne();
      assertThat(innerAccount1.getEmailAddress()).isEqualTo(ORIGINAL_EMAIL);

      // Look it up again.
      var innerAccount2 = database.find(AccountModel.class).setId(accountId).findOne();
      // Update this objects email.
      innerAccount2.setEmailAddress(UPDATED_EMAIL);
      innerAccount2.save();

      // Note: Account1 is updated too unexpectedly.
      assertThat(innerAccount1.getEmailAddress()).isEqualTo(UPDATED_EMAIL);
      // Note: Account1 is actually the same object as Account2.
      assertThat(innerAccount1).isSameAs(innerAccount2);
      transaction.commit();
    }

    // The outer account is the same still though.
    assertThat(outerAccount1.getEmailAddress()).isEqualTo(ORIGINAL_EMAIL);

    // Outside a transaction they are separate objects.
    var outerAccount2 = database.find(AccountModel.class).setId(accountId).findOne();
    outerAccount2.setEmailAddress(UPDATED_EMAIL);
    outerAccount2.save();

    // Account1 is not the same object as Account2.
    assertThat(outerAccount1).isNotSameAs(outerAccount2);

    // Updating the second view doesn't change the first.
    assertThat(outerAccount1.getEmailAddress()).isEqualTo(ORIGINAL_EMAIL);
  }

  /**
   * One way around unintentional changes is to use savepoints and rollback the inner transaction.
   *
   * <p>In CiviForm though we don't use savepoints and rollbacks in user requests, so this would be
   * exceptional in our typical programming model.
   */
  @Test
  public void transaction_sameObjectsInTransaction_canRollback() {
    final String ORIGINAL_EMAIL = "original@email.com";
    final String UPDATED_EMAIL_1 = "updated1@email.com";
    final String UPDATED_EMAIL_2 = "updated2@email.com";
    var account = new AccountModel();
    account.setEmailAddress(ORIGINAL_EMAIL);
    account.insert();

    var accountId = account.id;

    // Look up the account outside of a transaction.
    var outerAccount = database.find(AccountModel.class).setId(accountId).findOne();
    assertThat(outerAccount.getEmailAddress()).isEqualTo(ORIGINAL_EMAIL);

    try (Transaction transaction =
        DB.beginTransaction(TxScope.required().setIsolation(TxIsolation.SERIALIZABLE))) {
      // Note: MUST have nested savepoints on.
      transaction.setNestedUseSavepoint();

      // Let's update the outer account to show how it interacts with the transaction data.
      outerAccount.setEmailAddress(UPDATED_EMAIL_1);
      outerAccount.save();

      // Look up the account in a transaction.
      var innerAccount = database.find(AccountModel.class).setId(accountId).findOne();
      // Transaction updated the data and we see that.
      assertThat(innerAccount.getEmailAddress()).isEqualTo(UPDATED_EMAIL_1);

      try (Transaction innerTransaction =
          DB.beginTransaction(TxScope.required().setIsolation(TxIsolation.SERIALIZABLE))) {
        // Look it up again in another transaction.
        var innerInnerAccount = database.find(AccountModel.class).setId(accountId).findOne();
        // Update this objects email in the inner transaction.
        innerInnerAccount.setEmailAddress(UPDATED_EMAIL_2);
        innerInnerAccount.save();

        // innerAccount1 is updated also.
        assertThat(innerAccount.getEmailAddress()).isEqualTo(UPDATED_EMAIL_2);
        // innerAccount1 is the same object as Account2.
        assertThat(innerAccount).isSameAs(innerInnerAccount);

        // Note: outerAccount is unchanged as it's a different object.
        assertThat(outerAccount.getEmailAddress()).isEqualTo(UPDATED_EMAIL_1);
        // Note: If we refresh though, it sees the same database data in the transaction.
        outerAccount.refresh();
        assertThat(outerAccount.getEmailAddress()).isEqualTo(UPDATED_EMAIL_2);

        // Rollback the transaction that changed the transaction object.
        innerTransaction.rollback();
        // Note: innerAccount1 object is still updated.
        assertThat(innerAccount.getEmailAddress()).isEqualTo(UPDATED_EMAIL_2);
        // Note: Until we refresh, let's refresh innerAccount2 to further exemplify they're the
        // same object, and the importance of refreshing in a rollback.
        innerInnerAccount.refresh();
        // Note: It's back to the value set in the outer transaction.
        assertThat(innerAccount.getEmailAddress()).isEqualTo(UPDATED_EMAIL_1);
      }

      // For good measure verify it's the same value in the outer transaction.
      assertThat(innerAccount.getEmailAddress()).isEqualTo(UPDATED_EMAIL_1);
      // Note: Let's try to keep everything done in the outer transaction.
      transaction.commit();
    }

    // Note: Because it's a different object, our outerAccount still reflects the refreshed data in
    // the inner transaction.
    assertThat(outerAccount.getEmailAddress()).isEqualTo(UPDATED_EMAIL_2);
    // Until we refresh it, then we get the commited changed in the outerTransaction.
    outerAccount.refresh();
    assertThat(outerAccount.getEmailAddress()).isEqualTo(UPDATED_EMAIL_1);
  }

  /**
   * Using requiresNew Scope uses a different transaction and as such gives a different object.
   *
   * <p>In CiviForm though we don't use different simultaneous transactions, so this would be
   * exceptional in our typical programming model.
   */
  @Test
  public void transaction_sameObjectsInTransaction_requiresNew_givesDifferentObjects() {
    final String ORIGINAL_EMAIL = "original@email.com";
    final String UPDATED_EMAIL = "updated@email.com";
    var account = new AccountModel();
    account.setEmailAddress(ORIGINAL_EMAIL);
    account.insert();

    var accountId = account.id;

    var outerAccount = database.find(AccountModel.class).setId(accountId).findOne();
    assertThat(outerAccount.getEmailAddress()).isEqualTo(ORIGINAL_EMAIL);

    try (Transaction transaction =
        DB.beginTransaction(TxScope.required().setIsolation(TxIsolation.SERIALIZABLE))) {

      // Look up the account in a transaction.
      var innerAccount = database.find(AccountModel.class).setId(accountId).findOne();
      assertThat(innerAccount.getEmailAddress()).isEqualTo(ORIGINAL_EMAIL);

      // Note: Creating a separate transaction scope.
      try (Transaction innerTransaction =
          DB.beginTransaction(TxScope.requiresNew().setIsolation(TxIsolation.SERIALIZABLE))) {
        // Look it up again.
        var innerInnerAccount = database.find(AccountModel.class).setId(accountId).findOne();
        // Update this objects email.
        innerInnerAccount.setEmailAddress(UPDATED_EMAIL);
        innerInnerAccount.save();
        innerTransaction.commit();

        // Note: innerAccount is NOT updated.
        assertThat(innerAccount.getEmailAddress()).isEqualTo(ORIGINAL_EMAIL);
        // Note:  innerAccount is NOT the same object as Account2.
        assertThat(innerAccount).isNotSameAs(innerInnerAccount);
      }

      // And because they're different transactions, they see different views of the database.
      innerAccount.refresh();
      // innerAccount1 is unchanged relative to its transaction.
      assertThat(innerAccount.getEmailAddress()).isEqualTo(ORIGINAL_EMAIL);
    }
  }

  /**
   * However, in comparison to the above test, for some unknown reason the above doesn't work if you
   * also use savepoints.
   */
  @Test
  public void transaction_sameObjectsInTransaction_requiresNewAndSavepoints_givesSameObjects() {
    final String ORIGINAL_EMAIL = "original@email.com";
    final String UPDATED_EMAIL = "updated@email.com";
    var account = new AccountModel();
    account.setEmailAddress(ORIGINAL_EMAIL);
    account.insert();

    var accountId = account.id;

    // Look up the account.
    var outerAccount = database.find(AccountModel.class).setId(accountId).findOne();
    assertThat(outerAccount.getEmailAddress()).isEqualTo(ORIGINAL_EMAIL);

    try (Transaction transaction =
        DB.beginTransaction(TxScope.required().setIsolation(TxIsolation.SERIALIZABLE))) {
      // Note: Using savepoints for some reason changes the persistence modeling of using a separate
      // transaction.
      transaction.setNestedUseSavepoint();

      // Look up the account in a transaction.
      var innerAccount = database.find(AccountModel.class).setId(accountId).findOne();
      assertThat(innerAccount.getEmailAddress()).isEqualTo(ORIGINAL_EMAIL);

      // Note: Creating a separate transaction.
      try (Transaction innerTransaction =
          DB.beginTransaction(TxScope.requiresNew().setIsolation(TxIsolation.SERIALIZABLE))) {
        // Look it up again.
        var innerInnerAccount = database.find(AccountModel.class).setId(accountId).findOne();
        // Update this objects email.
        innerInnerAccount.setEmailAddress(UPDATED_EMAIL);

        // Note: innerAccount is updated unexpectedly.
        assertThat(innerAccount.getEmailAddress()).isEqualTo(UPDATED_EMAIL);
        // Note: innerAccount is the same object as innerInnerAccount unexpectedly.
        assertThat(innerAccount).isSameAs(innerInnerAccount);
      }
    }
  }
}
